# TritRPC v1 â€” Full Specification (repo copy)

This file mirrors the **full spec** provided in chat (Status: Draft 1.0). It enumerates
the normative requirements for envelope layout, TritPack243, TLEB3, AEAD, Profiles, Kafka,
Strict-Initial (PoE), and the reference hypergraph service.

For convenience, the **reference implementation** in `reference/tritrpc_v1.py` adheres to:
- Path-A (Avro Binary Encoding) for payloads,
- AEAD lane (XChaCha20-Poly1305 if available; else BLAKE2b MAC fallback labeled as such),
- HELLO/CHOOSE negotiation examples,
- Streaming with rolling 24-byte nonces,
- AUX structures: Trace, Sig (placeholder), PoE.

See `fixtures/` for **canonical hex vectors** generated by this reference.

## Canonicalization & Hashing (JSON / Receipts)

Any JSON that participates in hashing, signing, or receipt verification is **byte-canonicalized**
using **RFC 8785 (JSON Canonicalization Scheme, JCS)**. Implementations MUST NOT hash or sign
implementation-defined serializer output.

Normative steps (MUST):

1. **Parse** input as JSON per **RFC 8259** (no JSON5 extensions).
2. **Canonicalize** per **RFC 8785 (JCS)**:
   - UTF-8 output.
   - Deterministic object member ordering per JCS.
   - No insignificant whitespace.
   - String escaping per JCS/JSON rules.
   - Numbers rendered per JCS (shortest round-trippable decimal form).
3. **Reject non-finite numbers** (`NaN`, `+Inf`, `-Inf`).
4. **Hash/sign input** = **UTF-8 bytes** of the JCS canonical JSON produced in step (2).
5. **Compute content hash** using **BLAKE3** over those canonical bytes.

Receipts are considered replay-grade only when their hashes are computed via the JCS canonical
bytes described above. Implementations MUST pass the published canonicalization + BLAKE3 test
vectors before they are considered compliant.

Golden vectors (canonical JSON + expected BLAKE3) are maintained in
`fixtures/jcs_blake3_vectors.json`.
